---
description: >-
  D.A.G.G.E.R.は、directed acyclic gossip graph enabling replicationの略です、
  本項ではアーキテクチャを高次元で解説しています。
---

# D.A.G.G.E.R.

## **Introduction**

最新のリソースはこちらをご覧ください。:\
\
[D.A.G.G.E.R. Litepaper](https://github.com/GenesysGo/dagger-litepaper/blob/main/DAGGER-Litepaper.pdf)
[テストネット連載記事](https://www.shadow.cloud/blog/dagger-testnet-release)
[テストネット・デモ](https://dagger-hammer.shadow.cloud/)

_注意：このページは、すべての読者に適したハイレベルな説明と一般的な概念を堅持しています。これはホワイトペーパーとみなされるものではなく、より技術的な文書は、直接上に提供されているリンクを使用して見つけることができます。D.A.G.G.E.R.で_ [_SHDW_](https://docs.shadow.cloud/reference/shdw-token) _トークンがどのように利用されるかについての詳細は、_ [_SHDW_](https://docs.shadow.cloud/reference/shdw-token) _トークンのページ_ [_こちら_](https://docs.shadow.cloud/reference/shdw-token)_をご覧ください。このページは、最近リリースされたD.A.G.G.E.R.のライトペーパーやブログ記事との整合性を高めるため、現在変更中です_。

_D.A.G.G.E.R._ は、グラフベースのコンセンサスメカニズムを持つ分散システムです。プロトコル仕様を構成する5つのコンポーネントがあります。この記事では、これら5つのコンポーネントのそれぞれと、それらがどのように入ってくるリクエストと相互作用するかを、高レベルで説明します。簡単に言うと、トランザクションのユースケースは、Shadow Drive v2にファイルを保存するリクエストと考えることができます。

GenesysGoの _D.A.G.G.E.R._ は、多くの実装が可能であり、計画されていますが、フラッグシップ実装はShadow Drive v2（現在のShadow Drive v1.5をまもなくリリース予定の拡張版）です。このため、「トランザクション」とは、ユーザーから提出された書き込み要求のことだと考えています。このセクションでは、スピード、安定性、スケーラビリティが、私たちが最先端の非循環グラフ型コンセンサス技術の構築を選択した理由であることを説明し、締めくくりとします。

## **Overview**

これらのコンポーネントは、トランザクション（ユーザーの書き込み要求）のライフサイクルを通じて、受信したトランザクションが目にする順序で、下図に示されています：

<figure><img src="../.gitbook/assets/Dagger_Lifecycle2.png" alt=""><figcaption></figcaption></figure>

### **Key Terms**

本書では、入門者向けのヘルプとして、多くの専門用語にその定義へのリンクを付けています。以下のリストでは、この文書でよく使われるいくつかの用語を定義しています：

* トランザクション: ユーザーによって提出された書き込み要求。トランザクションには [raw bytes](dagger.md#raw-bytes-binary-data-that-is-made-up-of-0s-and-1s-usually-representing-a-string-of-text-a-file-or-an-image) 会員管理要求、シャドートランザクション（Shadow Drive/cloud 動作、例えばファイルの保存、VMをインスタンスする）などがあります。
* ブロック：root hashが [DAG](dagger.md#directed-acyclic-graph-a-graph-that-consists-of-directed-edges-with-no-cycles-used-to-represent-relationships-between-distributed-ledger-transactions) のノードに含まれる  [Merkle Tree](dagger.md#merkle-tree-a-data-structure-used-in-cryptography-to-verify-the-integrity-of-data-a-merkle-tree-allows-large-datasets-to-be-checked-for-consistency-and-completeness-without-having-to-download-the-entire-dataset) のノードにルートハッシュが含まれています。
* イベント: DAG内のノードで、親の[ハッシュ](dagger.md#cryptographic-hashes-a-one-way-function-used-to-map-data-of-any-size-to-a-fixed-length-value-used-to-create-digital-fingerprints-to-verify-data-integrity) 、タイムスタンプ、ブロックペイロード、前述の作成者の署名が含まれています。

### _D.A.G.G.E.R._ の非同期型コンセンサスを理解する

_D.A.G.G.E.R._ システムは、ローカルグラフ上の非同期計算によってイベントの順序に関する合意を達成し、効率的で安全な分散処理を保証します。このコンセンサスメカニズムは、ネットワーク内のデータの整合性と一貫性を維持するために極めて重要です。

_D.A.G.G.E.R._ システムでは、各ノードがネットワーク全体の状態の一部を表すローカルグラフを保持しています。ローカルグラフは、イベントを表す頂点と、イベント間の依存関係を示すエッジで構成されています。新しいイベントが生成されると、特定のルールに従ってローカルグラフに統合されます。

ローカルグラフを継続的に更新・処理するために、非同期計算が採用されています。このアプローチにより、ノードはグローバルな同期信号を待つことなく独立して動作することができ、システム全体のパフォーマンスとスケーラビリティを向上させることができます。_D.A.G.G.E.R._ のコンセンサスメカニズムの非同期性により、ノードは変化するネットワーク条件に適応し、高度な耐障害性を維持することができます。

_D.A.G.G.E.R._ コンセンサスアルゴリズムは、ローカルグラフ内のイベントの正しい順序付けを保証するために様々な技術を利用します。これらの技術には、投票メカニズム、評価システム、確率的アプローチなどが含まれます。これらの手法を活用することで、システムは効果的に競合を解決し、イベントのグローバルな順序付けに関するコンセンサスに達することができます。

## **Components**

### **Communicationsモジュール： ネットワークの受信・送信データについて**

Communicationsモジュールは、[ピア](dagger.md#peer-to-peer-a-type-of-network-architecture-in-which-each-node-in-the-network-can-act-as-both-a-client-and-a-server-in-a-peer-to-peer-network-nodes-communicate-directly-with-each-other-rather-than-through-a-central-server)との発信[同期](dagger.md#synchronization-requests-in-peer-to-peer-network-requests-sent-between-nodes-in-a-peer-to-peer-network-to-ensure-that-the-nodes-have-the-same-data)要求を初期化し、ピアからの同期応答をProcesserに転送し、ピアからの受信同期要求を処理し、トランザクションをProcesserに転送し、RPC要求をControllerに転送し、ピアIPデータベースを維持します。

* **Outgoing Sync Requests**
  * 同期要求を初期化するために、最近同期されたことのないアクティブなピアをランダムに選択することから始めます。
  * 現在のグラフの状態の要約とともに最新のピアリストが必要なので、CommunicationsモジュールはGraphモジュールに現在のグラフの状態を要約し、ピア1を選択する要求を送信します。
  * Communicationsは状態の要約と選択されたピアを受信し、ピアに送信して同期応答を待ち、Graphモジュールに転送されて消化されます。
  * Communicationsは状態の要約と選択されたピアを受信し、ピアに送信し、同期応答を待って、消化されるためにGraphモジュールに転送されます。
* **Incoming Sync Requests**
  * 受信した同期リクエストは直ちにGraphモジュールに転送されます。私たちが持っていて相手が持っていないすべての[イベント](dagger.md#events-an-occurrence-that-is-detected-by-a-distributed-ledger) を含むパッケージされた同期応答を待ち、それが相手に送り返されます。
* **Incoming Transactions**
  * ユーザーがトランザクションを送信すると、トランザクションを受信したCommunicationsモジュールは、それをProcesserに転送します。検証後、トランザクションはForesterとGraphモジュールを経由し、ブロックに含まれると、トランザクションが含まれたブロックを含むイベントの署名を送り返します。Communicationsモジュールは、この署名をユーザーに送り返します。これはブロックが[finalized](dagger.md#finalized-block-a-block-that-has-been-accepted-by-the-consensus-protocol-and-will-not-be-changed) したことを意味しないので注意しましょう。

<figure><img src="../.gitbook/assets/Docs_MindMap_4.png" alt=""><figcaption></figcaption></figure>

* **Incoming RPC Requests**
  * ユーザが、ファイルの読み取り、ブロックやトランザクションの問い合わせなど、いくつかの[RPC](dagger.md#rpc-request)リクエストを送信すると、そのリクエストはControllerに転送されます。Controllerは、Communicationsモジュールに元帳問い合わせの結果を送り返し、Communicationsモジュールはそれをユーザーに転送します。このRPC APIは _D.A.G.G.E.R._ のネイティブであり、JSON標準に準拠しています。

<figure><img src="../.gitbook/assets/RPC_Request_Graphic_Docs_Transparent.png" alt=""><figcaption></figcaption></figure>

### **Processerモジュール： 検証**

VerifierとForesterは、イベント、ブロック、トランザクションの検証を担当する[sibling modules](dagger.md#sibling-modules)です。検証はピアによって行われるイベントと、ユーザーによって行われる受信トランザクションに対して行われます。トランザクションの署名検証、ブロックの署名検証、ブロックの[root hash](dagger.md#root-hash)検証など、検証にはいくつかの形式があります。ピアイベントを処理する場合、Verifierはこれらの検証形式のうち最初の2つを担当し、Foresterはブロックを形成するトランザクションのMerkleツリーのroot hashの検証を担当します。受信したユーザートランザクションを処理する際、Foresterはブロックにまとめるトランザクションを収集し、ブロックを表すMerkle root hashを作成します。

Shadow Driveのようなファイルシステムアプリケーションの場合、Controllerモジュールは _D.A.G.G.E.R._ プロトコルを使用して台帳への読み取りと書き込みを実行します。これには、ファイルの安全性と回復力を確保するためのシュレッダーや消去コードなどの操作が含まれます。ユーザーがShadow Driveにファイルを保存するリクエストを提出すると、Foresterモジュールがトランザクションを収集し、ブロックにまとめます。次に、Verifireモジュールがトランザクションの署名を検証し、ブロック内のトランザクションのMerkleツリーのroot hashを検証します。ブロックが検証されると、そのブロックは _D.A.G.G.E.R._ 台帳に追加され、すべての取引の安全で改ざん不可能な記録を維持します。

オラクル、ブリッジ、VMオーケストレーションなどの他のユースケースの場合、Controllerモジュールは必要に応じて他のシステムやサービスに外部コールすることになります。例えば、ユーザーがShadow Compute上でスマートコントラクトを実行したい場合、Controllerモジュールは、トランザクションが有効で安全であることを確認するために、VerifierおよびForesterモジュールと対話します。Verifierはトランザクションの署名を検証し、Foresterはトランザクションのroot hashを検証します。

### **Graphモジュール： 非同期コンセンサス**

グラフには、2つの中核的な責務と、いくつかの協力的な責務があります。2つの中核的な責務は以下の通りです：

#### 1. syncレスポンスを処理してゴシップグラフを構築する

有向非循環Merkleベースのゴシップグラフは、情報を安全かつ効率的に整理・検証するための方法です。樹木のように、それぞれの枝が2つの小さな枝に分かれていき、最小の枝、つまり "葉"に達するまで続くと考えてください。それぞれの情報、つまり「データブロック」は、この葉の1つに格納されています。

ツリーの整合性を確保するため、データブロックごとに「ハッシュ」と呼ばれる固有のコードが作成されます。これらのハッシュコードは、ツリーの上に行くにつれて2つ1組で結合されます。このプロセスは、ツリーの最上位（ルート）に到達するまで繰り返されます。root hashはツリー全体を表すもので、ツリー内の情報が改ざんされていないことを確認するために使用されます。

要約すると、Merkleベースのゴシップグラフは、ハッシュと呼ばれるユニークなコードを用いて情報を安全に整理・検証するツリー構造です。ツリーは、ハッシュのペアを組み合わせて下から上に構築され、最終的にツリー全体を表す単一のroot hashが得られます。

<figure><img src="../.gitbook/assets/image.png" alt=""><figcaption><p>これはコンセプトグラフィックです</p></figcaption></figure>

この上のUMLクラス図は、4つのクラスで構成されています： MerkleTree、Node、Data、Hashです。

* MerkleTree: MerkleTreeの構造全体を表す。ツリーのroot hashを保持する `root` プロパティと、Data オブジェクトの配列に基づいて Merkleツリーを構築する `computeTree` メソッドを持ちます。
* Node: Merkleツリー内のノードを表現する。各ノードは `hash` プロパティと `left` と `right` の子ノードへのリファレンスを持ちます。
* Data: Merkleツリーのリーフノードに格納されているデータブロックを表す。各データブロックは値を持っています。
* Hash: Merkleツリーのデータブロックとノードに対して計算されるハッシュ値を表します。各ハッシュは値を持ちます。

この図では、MerkleTree クラスと Node クラスの構成、および Node、Data、Hash クラスの関連付けなど、これらのクラス間の関係を示しています。UML クラス図の目的は、ソフトウェア・システムの構造を抽象的かつ視覚的に表現することで、システムの理解、設計、保守を容易にすることです。これは概念的な目的で、Merkelのデータ構造がどのように機能するかを説明するのに役立つものでしかありません。_D.A.G.G.E.R._ はこのデータ構造のより高度な実装を使用しており、より多くの技術文書が公開されるにつれて、より詳細に説明されるでしょう。

#### 2. グラフを解析して、イベントの[consensus](dagger.md#consensus)順序を導き出す。協調的な任務は、通信モジュールがどのピアと同期するかを決めるのを助けることと、通信モジュールに通知することです。

* グラフイベントの順序に基づくコンセンサスは、_D.A.G.G.E.R._ のようなプロトコルの重要な構成要素です。DAGGERでは、各ノードが「シャドウグラフ」のローカルコピーを保持します。シャドウグラフは、基本的にシステムで発生したすべてのトランザクションとイベントを記録する非循環なグラフです。また、ノードはイベントやトランザクションに関する情報を共有するゴシップ・プロトコルを用いて互いに通信します。
* 新しいトランザクションがシステムに提出されると、まずそれを受信したノードによって検証されます。その後、ノードはトランザクションを含む新しいイベントを作成し、それをシャドウグラフのローカルコピーに追加します。その後、ノードは新しいイベントをネットワーク内の他のノードにゴシップします。
* イベントがゴシップされると、各ノードは新しいイベントを含めるためにシャドウグラフのローカルコピーを更新します。ノードはまた、シャドウグラフのイベントの順序に関する他のノードの意見に関する知識も更新します。ここでハッシュグラフ駆動型ゴシップが登場し、コンセンサスを得ることができるようになります。
* 各ノードは、システム内での重み付けに比例した仮想投票ウェイトを保持します。競合する2つのトランザクションが発生した場合、ノードは仮想投票ウェイトを使用して、シャドウグラフでどちらのトランザクションを優先すべきと考えるかを投票します。これは、他のノードとメッセージを交換して、イベントの順序に関する意見を収集することによって行われます。ネットワークの2/3以上が見て合意した取引は、"強く見られた "とみなされます。

<figure><img src="../.gitbook/assets/Screenshot 2023-03-21 133926.png" alt=""><figcaption><p>A high level concept of comms related to consensus</p></figcaption></figure>

### **Controllerモジュール： トランザクションの実行**

Controllerモジュールは[ledger](dagger.md#ledger)への読み込みと書き込みを実行します。これは _D.A.G.G.E.R._ の使用例によって最も異なる部分です。_D.A.G.G.E.R._ のファイルシステム用途(Shadow Drive など)では、[shredding](dagger.md#erasure-coding)や[erasure coding](dagger.md#erasure-coding)などのオペレーションがあります。オラクル、ブリッジ、[VM orchestration](dagger.md#virtual-machine-orchestration) (Shadow Computeなど)などの他の使用例については、ここで外部呼び出しが行われます。

### **トランザクションのライフサイクル**

_D.A.G.G.E.R._ コンセンサスネットワークの結論とまとめとして、トランザクションのライフサイクルをより詳細に再確認するために、以下のシーケンス図を示します:

<figure><img src="../.gitbook/assets/dagger_comprehensive.png" alt=""><figcaption></figcaption></figure>

## **_D.A.G.G.E.R_ はなぜ非循環グラフをコンセンサスに使っているのですか？**

プルーフオブステーク（PoS）と[proof-of-work](dagger.md#proof-of-work)（PoW）は、[blockchain](dagger.md#blockchain)networks で使われる最も人気のある合意メカニズムのうちの2つです。PoSでは、バリデータまたはノードは、保有する暗号通貨の量と「ステーク」する意思に基づいて、トランザクションを検証するために選ばれます。保有する暗号通貨の量が多ければ多いほど、バリデーターとして選ばれる確率は高くなります。PoWでは、マイナーが複雑な数学的問題を競って解決し、最初に解決した者には暗号通貨とトランザクションを検証する権利が与えられます。

一方、_D.A.G.G.E.R._ は、[directed acyclic](dagger.md#directed-acyclic-graph)グラフベース（DAG）の合意メカニズムで、ノード同士が直接通信して取引を共有、取引のDAGを形成します。このDAGでは、各ノードが独自の取引履歴を持ち、グラフ全体を分析し、合意された単一の取引順序を特定することで合意形成が行われます。この処理により、高いスループットと高速なファイナリティを実現できるため、高速性と拡張性が求められるアプリケーション（Shadow Drive、DAGGER Mobile、AIモデル学習など）に魅力的な選択肢となっています。

GenesysGo Shadow Driveのような分散型ストレージネットワークの場合、_D.A.G.G.E.R._ は水平スケーラビリティを可能にします。つまり、ネットワークの速度やセキュリティを損なうことなく、ノードを追加してストレージ容量や処理能力を増加させ、ネットワークを拡大することができます。これは、各ノードが独立してトランザクションを処理・検証し、DAG全体を分析することで最終的なコンセンサスを得ることができるためです。

一方、[Filecoin](dagger.md#filecoin)や[IPFS](dagger.md#ipfs)などのストレージ証明（PoS）合意機構では、暗号通貨の報酬と引き換えにデータの保存と取得を参加者にインセンティブを与えて分散ストレージ化を実現します。PoSシステムは、データが複数のノードに分散されるため、単一のノードがネットワークを侵害することが困難であり、集中型ストレージソリューションよりも高いセキュリティを提供できる可能性がああります。しかし、PoSシステムは通常、参加するために相当量のストレージ容量と計算機資源を必要とするため、一般市民には利用しにくいものとなっています。

まとめると、_D.A.G.G.E.R._ プロトコルは、高いスループット、速いファイナリティ、水平スケーラビリティを可能にする独自の合意メカニズムを提供し、Shadow Driveのような分散型アプリケーションにとって魅力的な選択肢となります。PoS、PoW、PoSのコンセンサスメカニズムは、いずれも異なる利点とトレードオフを提供し、どれを使用するかの選択は、アプリケーションの特定の要件に依存します。

[**Shadow Drive でビルドを開始する!**](../build/)

#### **このページで使用している用語**

#### **Blockchain:**

デジタル台帳技術の一種で、安全で分散化された方法で取引を記録するために使用されます。各取引は「ブロック」にまとめられ、ブロックの連鎖に追加され、発生したすべての取引の永久的な記録が作成されます。

#### **Consensus:**

参加者のグループが、真実の単一のバージョンに合意するプロセス。分散システムでは、ネットワーク内のすべてのノードがシステムの状態について同じ見解を持つことを保証するために、コンセンサスの達成は重要です。

#### **Cryptographic hashes:**

任意のサイズのデータを固定長の値にマッピングするために使用される一方向性関数です。データの整合性を検証するためのデジタル指紋の作成に使用されます。

#### **Directed acyclic graph:**

有向辺で構成され、サイクルのないグラフ。分散型台帳のトランザクション間の関係を表現するために使用されます。

#### **Distributed System:**

共通の目標を達成するために協力し合う、独立したコンピュータのネットワーク。分散システムでは、タスクは異なるノードに分割され、ノードは互いに通信・協調してタスクを完了させます。

#### **Distributed system file shredding:**

分散システムにおいて、ファイルを複数の断片に分割し、異なるコンピュータに保存する処理です。

#### **Erasure Coding:**

データを細かく分割してネットワーク上に分散させることで、冗長性を持たせ、一部が消失してもデータを復元できるようにする技術。

#### **Events:**

分散型台帳で検出される事象のこと。

#### **Finalized block:**

コンセンサスプロトコルによって受け入れられ、変更されることのないブロック。

#### **Hashgraph:**

分散型台帳技術の一種で、取引を記録するために有向非循環グラフ（DAG）を使用しています。Hashgraphは高速かつスケーラブルに設計されており、分散型ストレージネットワークなどのユースケースに適しています。

#### **IPFS:**

InterPlanetary File Systemは、ハイパーメディアを分散ファイルシステムに格納し、共有するためのコンテンツアドレス可能なピアツーピア方式を実現するために設計されたプロトコルおよびネットワークです。

#### **Filecoin:**

Filecoinは分散型ストレージネットワークで、誰でも余分なハードディスクスペースを貸し出して、ネイティブ暗号通貨であるFILの形でお金を稼ぐことができます。Filecoinプロジェクトは、ブロックチェーン技術の利点と既存のIPFSプロトコルを組み合わせ、安全でインセンティブに基づくストレージインフラを提供しようとしています。

#### **Ledger:**

あるシステムにおけるすべての取引の記録。デジタルシステムでは、台帳はデータベースや他のタイプのデータ構造として実装することができます。

#### **Merkle Tree:**

暗号技術において、データの整合性を検証するために用いられるデータ構造。Merkleツリーにより、大規模なデータセットをダウンロードすることなく、整合性と完全性をチェックすることができます。

#### **Node:**

ネットワークに接続されているコンピューターやその他のデバイスのこと。分散システムでは、各ノードが特定の機能を実行し、ネットワーク内の他のノードと通信してタスクを完了します。

#### **Orchestration:**

分散型システムにおいて、複数のコンポーネントやサービスを調整・管理するプロセス。分散型ストレージネットワークでは、ネットワーク上でデータが正しく保存・取得されるようにオーケストレーションが使用されます。

#### **Peer-to-Peer:**

ネットワークアーキテクチャの一種で、ネットワーク内の各ノードがクライアントとサーバーの両方の役割を果たすことができます。ピアツーピアネットワークでは、ノードは中央のサーバーを介さず、互いに直接通信します。

#### **Proof-of-Work:**

一部のブロックチェーンベースのシステムで、取引の検証や新しいブロックの作成に使用されるコンセンサスアルゴリズム。Proof-of-workでは、参加者は取引のブロックを検証する権利を得るために、複雑な数学的問題を解く必要があります。

#### **Protocol:**

ネットワーク上でのデータの送受信方法を規定する一連の規則と標準。分散システムでは、プロトコルは、ネットワーク内のすべてのノードが標準的な方法で通信することを保証します。

#### **Raw bytes:**

0と1で構成されるバイナリデータで、通常は文字列、ファイル、画像などを表現します。

#### **Replication:**

分散システムにおいて、ある場所から別の場所にデータをコピーするプロセス。レプリケーションは、ネットワーク内の1つまたは複数のノードに障害が発生した場合でも、データが利用できるようにするために使用されます。

#### **Root hash:**

Merkleツリーの全データを表現する単一の暗号ハッシュ。

#### **RPC request:**

分散型台帳ノード間の通信に使用される、通常HTTPコネクションを介したリモートプロシージャコールです。

#### **Sibling modules:**

別々のモジュールが連携して、分散型台帳を作成します。

#### **Smart Contract:**

ブロックチェーンなどのデジタル台帳に記録され、強制される自己実行型の契約。スマートコントラクトは、契約条件の履行を自動化し、分散型アプリケーションの作成に利用できます。

#### **Synchronization requests in peer-to-peer network:**

ピアツーピアネットワークのノード間で送信されるリクエストで、ノードが同じデータを持つことを保証するためのものです。

#### **Virtual machine orchestration:**

分散型システムにおいて、仮想マシンをプロビジョニングして管理するプロセス。
